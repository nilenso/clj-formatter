["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$rewrite-clj.node.integer","~:imports",null,"~:requires",["^ ","~$interop","~$rewrite-clj.interop","^:","^:","~$node","~$rewrite-clj.node.protocols","^<","^<"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$IntNode",["^ ","~:num-fields",2,"~:protocols",["^4",["~$cljs.core/IRecord","~$rewrite-clj.node.integer/Object","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$rewrite-clj.node.protocols/Node","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^5","~$rewrite-clj.node.integer/IntNode","~:file","out/rewrite_clj/node/integer.cljc","~:end-column",19,"~:type",true,"~:column",12,"~:internal-ctor",true,"~:line",9,"~:record",true,"~:end-line",9,"~:tag","~$function","~:skip-protocol-flag",["^4",["^C","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^P","^Q","^R","^S"]]],"~$->IntNode",["^ ","~:protocol-inline",null,"~:meta",["^ ","^U","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/integer.cljc","^V",19,"^X",12,"^Y",true,"~:factory","~:positional","^Z",9,"^10",9,"~:arglists",["~#list",["~$quote",["^1:",[["~$value","~$base"]]]]],"~:doc","Positional factory function for rewrite-clj.node.integer/IntNode."],"^5","~$rewrite-clj.node.integer/->IntNode","^U","out/rewrite_clj/node/integer.cljc","^V",19,"~:method-params",["^1:",[["^1<","^1="]]],"~:protocol-impl",null,"~:arglists-meta",["^1:",[null,null]],"^X",1,"^Y",true,"~:variadic?",false,"^17","^18","^Z",9,"~:ret-tag","^T","^10",9,"~:max-fixed-arity",2,"~:fn-var",true,"^19",["^1:",["^1;",["^1:",[["^1<","^1="]]]]],"^1>","Positional factory function for rewrite-clj.node.integer/IntNode."],"~$map->IntNode",["^ ","^15",null,"^16",["^ ","^U","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/integer.cljc","^V",19,"^X",12,"^Y",true,"^17","~:map","^Z",9,"^10",9,"^19",["^1:",["^1;",["^1:",[["~$G__3075"]]]]],"^1>","Factory function for rewrite-clj.node.integer/IntNode, taking a map of keywords to field values."],"^5","~$rewrite-clj.node.integer/map->IntNode","^U","out/rewrite_clj/node/integer.cljc","^V",19,"^1@",["^1:",[["^1I"]]],"^1A",null,"^1B",["^1:",[null,null]],"^X",1,"^Y",true,"^1C",false,"^17","^1H","^Z",9,"^1D","^T","^10",9,"^1E",1,"^1F",true,"^19",["^1:",["^1;",["^1:",[["^1I"]]]]],"^1>","Factory function for rewrite-clj.node.integer/IntNode, taking a map of keywords to field values."],"~$integer-node",["^ ","^15",null,"^16",["^ ","^U","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/integer.cljc","^Z",37,"^X",7,"^10",37,"^V",19,"^19",["^1:",["^1;",["^1:",[["^1<"],["^1<","^1="]]]]],"^1>","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```\n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output.","~:top-fn",["^ ","^1C",false,"~:fixed-arity",2,"^1E",2,"^1@",[["^1<"],["^1<","^1="]],"^19",["^1:",[["^1<"],["^1<","^1="]]],"^1B",["^1:",[null,null]]]],"^5","~$rewrite-clj.node.integer/integer-node","^U","out/rewrite_clj/node/integer.cljc","^V",19,"^1L",["^ ","^1C",false,"^1M",2,"^1E",2,"^1@",[["^1<"],["^1<","^1="]],"^19",["^1:",[["^1<"],["^1<","^1="]]],"^1B",["^1:",[null,null]]],"^1@",[["^1<"],["^1<","^1="]],"^1A",null,"^1M",2,"^1B",["^1:",[null,null]],"^X",1,"^1C",false,"~:methods",[["^ ","^1M",1,"^1C",false,"^11","~$any"],["^ ","^1M",2,"^1C",false,"^11","^T"]],"^Z",37,"^10",37,"^1E",2,"^1F",true,"^19",["^1:",[["^1<"],["^1<","^1="]]],"^1>","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```\n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^1=","~:int","~:value","^1<","~:token","~:base"]],"~:order",["^1V","^1X","^1W","^1U","^1<","^1="]],"^1>",null,"~:as-aliases",["^ "]]