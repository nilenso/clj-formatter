["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$rewrite-clj.node.stringz","~:imports",null,"~:requires",["^ ","~$string","~$clojure.string","^:","^:","~$edn","~$cljs.tools.reader.edn","^<","^<","~$clojure.tools.reader.edn","^<","~$node","~$rewrite-clj.node.protocols","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$wrap-string",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/stringz.cljc","~:line",10,"~:column",8,"~:end-line",10,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^M",[["~$s"]]]]]],"^K",true,"^5","~$rewrite-clj.node.stringz/wrap-string","^F","out/rewrite_clj/node/stringz.cljc","^J",19,"~:method-params",["^M",[["~$s"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^H",1,"~:variadic?",false,"^G",10,"~:ret-tag","^9","^I",10,"~:max-fixed-arity",1,"~:fn-var",true,"^L",["^M",["^N",["^M",[["~$s"]]]]]],"~$join-lines",["^ ","^D",null,"^E",["^ ","^F","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/stringz.cljc","^G",13,"^H",8,"^I",13,"^J",18,"^K",true,"^L",["^M",["^N",["^M",[["~$lines"]]]]]],"^K",true,"^5","~$rewrite-clj.node.stringz/join-lines","^F","out/rewrite_clj/node/stringz.cljc","^J",18,"^P",["^M",[["^X"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",13,"^T","^9","^I",13,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^X"]]]]]],"~$StringNode",["^ ","~:num-fields",1,"~:protocols",["^4",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$rewrite-clj.node.stringz/Object","~$cljs.core/IIterable","~$rewrite-clj.node.protocols/Node","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^5","~$rewrite-clj.node.stringz/StringNode","^F","out/rewrite_clj/node/stringz.cljc","^J",22,"~:type",true,"^H",12,"~:internal-ctor",true,"^G",16,"~:record",true,"^I",16,"~:tag","~$function","~:skip-protocol-flag",["^4",["^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:","^1<","^1>","^1?","^1@","^1A"]]],"~$->StringNode",["^ ","^D",null,"^E",["^ ","^F","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/stringz.cljc","^J",22,"^H",12,"^1D",true,"~:factory","~:positional","^G",16,"^I",16,"^L",["^M",["^N",["^M",[["^X"]]]]],"~:doc","Positional factory function for rewrite-clj.node.stringz/StringNode."],"^5","~$rewrite-clj.node.stringz/->StringNode","^F","out/rewrite_clj/node/stringz.cljc","^J",22,"^P",["^M",[["^X"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^1D",true,"^S",false,"^1J","^1K","^G",16,"^T","^1B","^I",16,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^X"]]]]],"^1L","Positional factory function for rewrite-clj.node.stringz/StringNode."],"~$map->StringNode",["^ ","^D",null,"^E",["^ ","^F","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/stringz.cljc","^J",22,"^H",12,"^1D",true,"^1J","~:map","^G",16,"^I",16,"^L",["^M",["^N",["^M",[["~$G__2632"]]]]],"^1L","Factory function for rewrite-clj.node.stringz/StringNode, taking a map of keywords to field values."],"^5","~$rewrite-clj.node.stringz/map->StringNode","^F","out/rewrite_clj/node/stringz.cljc","^J",22,"^P",["^M",[["^1P"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^1D",true,"^S",false,"^1J","^1O","^G",16,"^T","^1B","^I",16,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^1P"]]]]],"^1L","Factory function for rewrite-clj.node.stringz/StringNode, taking a map of keywords to field values."],"~$string-node",["^ ","^D",null,"^E",["^ ","^F","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/stringz.cljc","^G",42,"^H",7,"^I",42,"^J",18,"^L",["^M",["^N",["^M",[["^X"]]]]],"^1L","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"],"^5","~$rewrite-clj.node.stringz/string-node","^F","out/rewrite_clj/node/stringz.cljc","^J",18,"^P",["^M",[["^X"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",42,"^T","^1B","^I",42,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^X"]]]]],"^1L","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:multi-line","~:lines","~:string","~:token","^X"]],"~:order",["^1Y","^1X","^1[","^1Z","^X"]],"^1L",null,"~:as-aliases",["^ "]]