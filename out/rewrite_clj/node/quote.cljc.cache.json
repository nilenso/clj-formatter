["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$rewrite-clj.node.quote","~:imports",null,"~:requires",["^ ","~$node","~$rewrite-clj.node.protocols","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$QuoteNode",["^ ","~:num-fields",4,"~:protocols",["^4",["~$cljs.core/IRecord","~$rewrite-clj.node.quote/Object","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$rewrite-clj.node.protocols/InnerNode","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$rewrite-clj.node.protocols/Node","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^5","~$rewrite-clj.node.quote/QuoteNode","~:file","out/rewrite_clj/node/quote.cljc","~:end-column",21,"~:type",true,"~:column",12,"~:internal-ctor",true,"~:line",8,"~:record",true,"~:end-line",8,"~:tag","~$function","~:skip-protocol-flag",["^4",["^A","^C","^D","^E","^F","^G","^I","^J","^K","^L","^M","^O","^P","^Q","^R"]]],"~$->QuoteNode",["^ ","~:protocol-inline",null,"~:meta",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^U",21,"^W",12,"^X",true,"~:factory","~:positional","^Y",8,"^[",8,"~:arglists",["~#list",["~$quote",["^19",[["~$tag","~$prefix","~$sym","~$children"]]]]],"~:doc","Positional factory function for rewrite-clj.node.quote/QuoteNode."],"^5","~$rewrite-clj.node.quote/->QuoteNode","^T","out/rewrite_clj/node/quote.cljc","^U",21,"~:method-params",["^19",[["^1;","^1<","^1=","^1>"]]],"~:protocol-impl",null,"~:arglists-meta",["^19",[null,null]],"^W",1,"^X",true,"~:variadic?",false,"^16","^17","^Y",8,"~:ret-tag","^S","^[",8,"~:max-fixed-arity",4,"~:fn-var",true,"^18",["^19",["^1:",["^19",[["^1;","^1<","^1=","^1>"]]]]],"^1?","Positional factory function for rewrite-clj.node.quote/QuoteNode."],"~$map->QuoteNode",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^U",21,"^W",12,"^X",true,"^16","~:map","^Y",8,"^[",8,"^18",["^19",["^1:",["^19",[["~$G__2876"]]]]],"^1?","Factory function for rewrite-clj.node.quote/QuoteNode, taking a map of keywords to field values."],"^5","~$rewrite-clj.node.quote/map->QuoteNode","^T","out/rewrite_clj/node/quote.cljc","^U",21,"^1A",["^19",[["^1J"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^X",true,"^1D",false,"^16","^1I","^Y",8,"^1E","^S","^[",8,"^1F",1,"^1G",true,"^18",["^19",["^1:",["^19",[["^1J"]]]]],"^1?","Factory function for rewrite-clj.node.quote/QuoteNode, taking a map of keywords to field values."],"~$->node",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^Y",37,"^W",8,"^[",37,"^U",14,"~:private",true,"^18",["^19",["^1:",["^19",[["~$t","^1<","^1=","^1>"]]]]]],"^1M",true,"^5","~$rewrite-clj.node.quote/->node","^T","out/rewrite_clj/node/quote.cljc","^U",14,"^1A",["^19",[["~$t","^1<","^1=","^1>"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^1D",false,"^Y",37,"^1E","^S","^[",37,"^1F",4,"^1G",true,"^18",["^19",["^1:",["^19",[["~$t","^1<","^1=","^1>"]]]]]],"~$quote-node",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^Y",42,"^W",7,"^[",42,"^U",17,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"^5","~$rewrite-clj.node.quote/quote-node","^T","out/rewrite_clj/node/quote.cljc","^U",17,"^1A",["^19",[["^1>"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^1D",false,"^Y",42,"^1E","^S","^[",42,"^1F",1,"^1G",true,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"~$syntax-quote-node",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^Y",67,"^W",7,"^[",67,"^U",24,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"^5","~$rewrite-clj.node.quote/syntax-quote-node","^T","out/rewrite_clj/node/quote.cljc","^U",24,"^1A",["^19",[["^1>"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^1D",false,"^Y",67,"^1E","^S","^[",67,"^1F",1,"^1G",true,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"~$unquote-node",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^Y",92,"^W",7,"^[",92,"^U",19,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"^5","~$rewrite-clj.node.quote/unquote-node","^T","out/rewrite_clj/node/quote.cljc","^U",19,"^1A",["^19",[["^1>"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^1D",false,"^Y",92,"^1E","^S","^[",92,"^1F",1,"^1G",true,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"~$unquote-splicing-node",["^ ","^14",null,"^15",["^ ","^T","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node/quote.cljc","^Y",117,"^W",7,"^[",117,"^U",28,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"\n   ```"],"^5","~$rewrite-clj.node.quote/unquote-splicing-node","^T","out/rewrite_clj/node/quote.cljc","^U",28,"^1A",["^19",[["^1>"]]],"^1B",null,"^1C",["^19",[null,null]],"^W",1,"^1D",false,"^Y",117,"^1E","^S","^[",117,"^1F",1,"^1G",true,"^18",["^19",["^1:",["^19",[["^1>"]]]]],"^1?","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"\n   ```"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^1;","~:children","~:unquote-splicing","~:unquote","^1>","~$unquote-splicing","~:sym","~:prefix","~$unquote","~:syntax-quote","~:quote","^1=","^1<","^10","^1:"]],"~:order",["^10","^24","^23","^1[","^27","^1;","^1<","^1=","^1>","^1:","^26","^21","^25","^20","^22"]],"^1?",null,"~:as-aliases",["^ "]]