["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",["~$string","~$coerce"]],"~:name","~$rewrite-clj.node","~:imports",null,"~:requires",["^ ","~$rewrite-clj.node.stringz","^;","~$rewrite-clj.node.meta","^<","~$rewrite-clj.node.integer","^=","~$rewrite-clj.node.token","^>","~$rewrite-clj.node.seq","^?","~$rewrite-clj.node.extras","^@","~$rewrite-clj.node.fn","^A","~$rewrite-clj.node.reader-macro","^B","~$rewrite-clj.node.keyword","^C","~$rewrite-clj.node.comment","^D","~$rewrite-clj.node.quote","^E","~$rewrite-clj.node.protocols","^F","~$rewrite-clj.node.uneval","^G","~$rewrite-clj.node.regex","^H","~$rewrite-clj.node.whitespace","^I","~$rewrite-clj.node.namespaced-map","^J","~$rewrite-clj.node.forms","^K","~$rewrite-clj.node.coercer","^L"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$child-sexprs",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","~:line",118,"~:column",7,"~:end-line",118,"~:end-column",19,"~:arglists",["~#list",["~$quote",["^Y",[["~$node"],["^[","~$opts"]]]]],"~:doc","Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",[["^["],["^[","^10"]],"^X",["^Y",[["^["],["^[","^10"]]],"~:arglists-meta",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/child-sexprs","^S","out/rewrite_clj/node.cljc","^W",19,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^["],["^[","^10"]],"^X",["^Y",[["^["],["^[","^10"]]],"^17",["^Y",[null,null]]],"^16",[["^["],["^[","^10"]],"~:protocol-impl",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"~:methods",[["^ ","^14",1,"^13",false,"~:tag","~$any"],["^ ","^14",2,"^13",false,"^1;",["^4",["~$cljs.core/LazySeq","~$clj-nil"]]]],"^T",118,"^V",118,"^15",2,"~:fn-var",true,"^X",["^Y",[["^["],["^[","^10"]]],"^11","Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)"],"~$tag",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",201,"^U",7,"^V",201,"^W",10,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns keyword representing type of `node`."],"^7","~$rewrite-clj.node/tag","^S","out/rewrite_clj/node.cljc","^W",10,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",201,"~:ret-tag","^1<","^V",201,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns keyword representing type of `node`."],"~$whitespace?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",830,"^U",7,"^V",830,"^W",18,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents Clojure whitespace."],"^7","~$rewrite-clj.node/whitespace?","^S","out/rewrite_clj/node.cljc","^W",18,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",830,"^1B","~$boolean","^V",830,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents Clojure whitespace."],"~$whitespace-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",825,"^U",7,"^V",825,"^W",22,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create whitespace node of string `s`, where `s` is one or more space characters."],"^7","~$rewrite-clj.node/whitespace-node","^S","out/rewrite_clj/node.cljc","^W",22,"^16",["^Y",[["~$s"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",825,"^1B","~$rewrite-clj.node.whitespace/WhitespaceNode","^V",825,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create whitespace node of string `s`, where `s` is one or more space characters."],"~$fn-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",247,"^U",7,"^V",247,"^W",14,"^X",["^Y",["^Z",["^Y",[["~$children"]]]]],"^11","Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \"#(+ 1 %1)\"\n   ```"],"^7","~$rewrite-clj.node/fn-node","^S","out/rewrite_clj/node.cljc","^W",14,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",247,"^1B","~$rewrite-clj.node.fn/FnNode","^V",247,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \"#(+ 1 %1)\"\n   ```"],"~$map-context-clear",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",191,"^U",7,"^V",191,"^W",24,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Removes map-qualifier context for `node`"],"^7","~$rewrite-clj.node/map-context-clear","^S","out/rewrite_clj/node.cljc","^W",24,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",191,"^1B","^1<","^V",191,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Removes map-qualifier context for `node`"],"~$linebreak?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",805,"^U",7,"^V",805,"^W",17,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents one or more linebreaks."],"^7","~$rewrite-clj.node/linebreak?","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",805,"^1B","^1E","^V",805,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents one or more linebreaks."],"~$var-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",534,"^U",7,"^V",534,"^W",15,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a var where `children` is either a\n   sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"#'my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the var\n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \"#'  my-var\"\n   ```"],"^7","~$rewrite-clj.node/var-node","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",534,"^1B","~$rewrite-clj.node.reader-macro/ReaderNode","^V",534,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a var where `children` is either a\n   sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"#'my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the var\n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \"#'  my-var\"\n   ```"],"~$vector-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",640,"^U",7,"^V",640,"^W",18,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \"[1 2 3]\"\n   ```"],"^7","~$rewrite-clj.node/vector-node","^S","out/rewrite_clj/node.cljc","^W",18,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",640,"^1B","~$rewrite-clj.node.seq/SeqNode","^V",640,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \"[1 2 3]\"\n   ```"],"~$eval-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",486,"^U",7,"^V",486,"^W",16,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \"#=(inc 1)\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the form\n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \"#=   (inc 1)\"\n   ```"],"^7","~$rewrite-clj.node/eval-node","^S","out/rewrite_clj/node.cljc","^W",16,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",486,"^1B","^1S","^V",486,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \"#=(inc 1)\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the form\n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \"#=   (inc 1)\"\n   ```"],"~$deref-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",466,"^U",7,"^V",466,"^W",17,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing the dereferencing of a form\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"@my-var\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \"@  my-var\"\n   ```"],"^7","~$rewrite-clj.node/deref-node","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",466,"^1B","~$rewrite-clj.node.reader-macro/DerefNode","^V",466,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing the dereferencing of a form\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"@my-var\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \"@  my-var\"\n   ```"],"~$integer-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",281,"^U",7,"^V",281,"^W",19,"^X",["^Y",["^Z",["^Y",[["~$value"],["^21","~$base"]]]]],"^11","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```\n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output.","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^21"],["^21","^22"]],"^X",["^Y",[["^21"],["^21","^22"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/integer-node","^S","out/rewrite_clj/node.cljc","^W",19,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^21"],["^21","^22"]],"^X",["^Y",[["^21"],["^21","^22"]]],"^17",["^Y",[null,null]]],"^16",[["^21"],["^21","^22"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^1<"],["^ ","^14",2,"^13",false,"^1;","~$rewrite-clj.node.integer/IntNode"]],"^T",281,"^V",281,"^15",2,"^1?",true,"^X",["^Y",[["^21"],["^21","^22"]]],"^11","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```\n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output."],"~$comma-separated",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",795,"^U",7,"^V",795,"^W",22,"^X",["^Y",["^Z",["^Y",[["~$nodes"]]]]],"^11","Interleave `nodes` with `\", \"` nodes."],"^7","~$rewrite-clj.node/comma-separated","^S","out/rewrite_clj/node.cljc","^W",22,"^16",["^Y",[["^26"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",795,"^1B","^1=","^V",795,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^26"]]]]],"^11","Interleave `nodes` with `\", \"` nodes."],"^1J",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",113,"^U",7,"^V",113,"^W",15,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns child nodes for `node`."],"^7","~$rewrite-clj.node/children","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",113,"^1B","^1<","^V",113,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns child nodes for `node`."],"~$newlines",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",810,"^U",7,"^V",810,"^W",15,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Create node representing `n` newline characters."],"^7","~$rewrite-clj.node/newlines","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["~$n"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",810,"^1B","~$rewrite-clj.node.whitespace/NewlineNode","^V",810,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Create node representing `n` newline characters."],"~$sexprs",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",175,"^U",7,"^V",175,"^W",13,"^X",["^Y",["^Z",["^Y",[["^26"],["^26","^10"]]]]],"^11","Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^26"],["^26","^10"]],"^X",["^Y",[["^26"],["^26","^10"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/sexprs","^S","out/rewrite_clj/node.cljc","^W",13,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^26"],["^26","^10"]],"^X",["^Y",[["^26"],["^26","^10"]]],"^17",["^Y",[null,null]]],"^16",[["^26"],["^26","^10"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^1<"],["^ ","^14",2,"^13",false,"^1;","^1="]],"^T",175,"^V",175,"^15",2,"^1?",true,"^X",["^Y",[["^26"],["^26","^10"]]],"^11","Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$inner?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",127,"^U",7,"^V",127,"^W",13,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` can have children."],"^7","~$rewrite-clj.node/inner?","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",127,"^1B","^1<","^V",127,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` can have children."],"~$replace-children",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",152,"^U",7,"^V",152,"^W",23,"^X",["^Y",["^Z",["^Y",[["^[","^1J"]]]]],"^11","Returns `node` replacing current children with `children`."],"^7","~$rewrite-clj.node/replace-children","^S","out/rewrite_clj/node.cljc","^W",23,"^16",["^Y",[["^[","^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",152,"^1B","^1<","^V",152,"^15",2,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^[","^1J"]]]]],"^11","Returns `node` replacing current children with `children`."],"~$comma?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",840,"^U",7,"^V",840,"^W",13,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents one or more commas."],"^7","~$rewrite-clj.node/comma?","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",840,"^1B","^1E","^V",840,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` represents one or more commas."],"~$forms-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",264,"^U",7,"^V",264,"^W",17,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \"1 2\"\n   ```\n   "],"^7","~$rewrite-clj.node/forms-node","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",264,"^1B","~$rewrite-clj.node.forms/FormsNode","^V",264,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \"1 2\"\n   ```\n   "],"~$string-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",657,"^U",7,"^V",657,"^W",18,"^X",["^Y",["^Z",["^Y",[["~$lines"]]]]],"^11","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"],"^7","~$rewrite-clj.node/string-node","^S","out/rewrite_clj/node.cljc","^W",18,"^16",["^Y",[["^2H"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",657,"^1B","~$rewrite-clj.node.stringz/StringNode","^V",657,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^2H"]]]]],"^11","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"],"~$meta-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",340,"^U",7,"^V",340,"^W",16,"^X",["^Y",["^Z",["^Y",[["^1J"],["~$metadata","~$data"]]]]],"^11","Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^:foo [1]\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^{:foo 42} [1]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \"^:foo [1]\"\n   ```\n   See also: [[raw-meta-node]]","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^2L","^2M"]],"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/meta-node","^S","out/rewrite_clj/node.cljc","^W",16,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^2L","^2M"]],"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^17",["^Y",[null,null]]],"^16",[["^1J"],["^2L","^2M"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","~$rewrite-clj.node.meta/MetaNode"],["^ ","^14",2,"^13",false,"^1;","^2O"]],"^T",340,"^V",340,"^15",2,"^1?",true,"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^11","Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^:foo [1]\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^{:foo 42} [1]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \"^:foo [1]\"\n   ```\n   See also: [[raw-meta-node]]"],"~$whitespace-nodes",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",845,"^U",7,"^V",845,"^W",23,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Convert string `s` of whitespace to whitespace/newline nodes."],"^7","~$rewrite-clj.node/whitespace-nodes","^S","out/rewrite_clj/node.cljc","^W",23,"^16",["^Y",[["~$s"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",845,"^1B","^1=","^V",845,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Convert string `s` of whitespace to whitespace/newline nodes."],"~$printable-only?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",147,"^U",7,"^V",147,"^W",22,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return true if `node` cannot be converted to an s-expression element."],"^7","~$rewrite-clj.node/printable-only?","^S","out/rewrite_clj/node.cljc","^W",22,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",147,"^1B","^1<","^V",147,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return true if `node` cannot be converted to an s-expression element."],"~$map-qualifier-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",406,"^U",7,"^V",406,"^W",25,"^X",["^Y",["^Z",["^Y",[["~$auto-resolved?","~$prefix"]]]]],"^11","Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; qualified\n   (-> (n/map-qualifier-node false \"my-prefix\")\n       n/string)\n   ;; => \":my-prefix\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \"::\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \"my-ns-alias\")\n       n/string)\n   ;; => \"::my-ns-alias\"\n   ```"],"^7","~$rewrite-clj.node/map-qualifier-node","^S","out/rewrite_clj/node.cljc","^W",25,"^16",["^Y",[["^2U","^2V"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",406,"^1B","~$rewrite-clj.node.namespaced-map/MapQualifierNode","^V",406,"^15",2,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^2U","^2V"]]]]],"^11","Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; qualified\n   (-> (n/map-qualifier-node false \"my-prefix\")\n       n/string)\n   ;; => \":my-prefix\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \"::\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \"my-ns-alias\")\n       n/string)\n   ;; => \"::my-ns-alias\"\n   ```"],"~$leader-length",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",132,"^U",7,"^V",132,"^W",20,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns number of characters before children for `node`."],"^7","~$rewrite-clj.node/leader-length","^S","out/rewrite_clj/node.cljc","^W",20,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",132,"^1B","^1<","^V",132,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns number of characters before children for `node`."],"~$sexpr-able?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",168,"^U",7,"^V",168,"^W",18,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"^7","~$rewrite-clj.node/sexpr-able?","^S","out/rewrite_clj/node.cljc","^W",18,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",168,"^1B","^1E","^V",168,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"~$regex-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",452,"^U",7,"^V",452,"^W",17,"^X",["^Y",["^Z",["^Y",[["~$pattern-string"]]]]],"^11","Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \"my\\\\.lil.*regex\")\n       n/string)\n   ;; => \"#\\\"my\\\\.lil.*regex\\\"\"\n   ```"],"^7","~$rewrite-clj.node/regex-node","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["^32"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",452,"^1B","~$rewrite-clj.node.regex/RegexNode","^V",452,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^32"]]]]],"^11","Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \"my\\\\.lil.*regex\")\n       n/string)\n   ;; => \"#\\\"my\\\\.lil.*regex\\\"\"\n   ```"],"~$list-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",555,"^U",7,"^V",555,"^W",16,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \"(1 2 3)\"\n   ```"],"^7","~$rewrite-clj.node/list-node","^S","out/rewrite_clj/node.cljc","^W",16,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",555,"^1B","^1V","^V",555,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \"(1 2 3)\"\n   ```"],"~$sexpr",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",157,"^U",7,"^V",157,"^W",12,"^X",["^Y",["^Z",["^Y",[["^["],["^[","^10"]]]]],"^11","Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^["],["^[","^10"]],"^X",["^Y",[["^["],["^[","^10"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/sexpr","^S","out/rewrite_clj/node.cljc","^W",12,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^["],["^[","^10"]],"^X",["^Y",[["^["],["^[","^10"]]],"^17",["^Y",[null,null]]],"^16",[["^["],["^[","^10"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^1<"],["^ ","^14",2,"^13",false,"^1;","^1<"]],"^T",157,"^V",157,"^15",2,"^1?",true,"^X",["^Y",[["^["],["^[","^10"]]],"^11","Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$namespaced-map-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",431,"^U",7,"^V",431,"^W",26,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \"#::my-ns-alias {:a 1}\"\n   ```\n\n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]]."],"^7","~$rewrite-clj.node/namespaced-map-node","^S","out/rewrite_clj/node.cljc","^W",26,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",431,"^1B","~$rewrite-clj.node.namespaced-map/NamespacedMapNode","^V",431,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \"#::my-ns-alias {:a 1}\"\n   ```\n\n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]]."],"^21",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",206,"^U",30,"^V",206,"^W",35,"~:deprecated","0.4.0","^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) "],"^7","~$rewrite-clj.node/value","^S","out/rewrite_clj/node.cljc","^W",35,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",206,"^3<","0.4.0","^1B",["^4",["^1<","^1>"]],"^V",206,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) "],"~$syntax-quote-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",697,"^U",7,"^V",697,"^W",24,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"^7","~$rewrite-clj.node/syntax-quote-node","^S","out/rewrite_clj/node.cljc","^W",24,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",697,"^1B","~$rewrite-clj.node.quote/QuoteNode","^V",697,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"~$comma-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",835,"^U",7,"^V",835,"^W",17,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create comma node of string `s`, where `s` is one or more comma characters."],"^7","~$rewrite-clj.node/comma-node","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["~$s"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",835,"^1B","~$rewrite-clj.node.whitespace/CommaNode","^V",835,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create comma node of string `s`, where `s` is one or more comma characters."],"~$newline-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",815,"^U",7,"^V",815,"^W",19,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create newline node of string `s`, where `s` is one or more linebreak characters."],"^7","~$rewrite-clj.node/newline-node","^S","out/rewrite_clj/node.cljc","^W",19,"^16",["^Y",[["~$s"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",815,"^1B","^2;","^V",815,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^11","Create newline node of string `s`, where `s` is one or more linebreak characters."],"~$unquote-splicing-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",739,"^U",7,"^V",739,"^W",28,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"\n   ```"],"^7","~$rewrite-clj.node/unquote-splicing-node","^S","out/rewrite_clj/node.cljc","^W",28,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",739,"^1B","^3@","^V",739,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"\n   ```"],"~$map-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",572,"^U",7,"^V",572,"^W",15,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :b 2}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \"{:a}\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :a 2}\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys)."],"^7","~$rewrite-clj.node/map-node","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",572,"^1B","^1V","^V",572,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :b 2}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \"{:a}\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :a 2}\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys)."],"^5",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",196,"^U",7,"^V",196,"^W",13,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return the string version of `node`."],"^7","~$rewrite-clj.node/string","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",196,"^1B","^1<","^V",196,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return the string version of `node`."],"~$map-context-apply",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",186,"^U",7,"^V",186,"^W",24,"^X",["^Y",["^Z",["^Y",[["^[","~$map-qualifier"]]]]],"^11","Applies `map-qualifier` context to `node`"],"^7","~$rewrite-clj.node/map-context-apply","^S","out/rewrite_clj/node.cljc","^W",24,"^16",["^Y",[["^[","^3L"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",186,"^1B","^1<","^V",186,"^15",2,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^[","^3L"]]]]],"^11","Applies `map-qualifier` context to `node`"],"~$reader-macro-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",511,"^U",7,"^V",511,"^W",24,"^X",["^Y",["^Z",["^Y",[["^1J"],["~$macro-node","~$form-node"]]]]],"^11","Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro)\n                            (n/token-node 42))\n       n/string)\n   ;; => \"#my-macro 42\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \"#my-macro    42\"\n   ```","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^3O","^3P"]],"^X",["^Y",[["^1J"],["^3O","^3P"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/reader-macro-node","^S","out/rewrite_clj/node.cljc","^W",24,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^3O","^3P"]],"^X",["^Y",[["^1J"],["^3O","^3P"]]],"^17",["^Y",[null,null]]],"^16",[["^1J"],["^3O","^3P"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","~$rewrite-clj.node.reader-macro/ReaderMacroNode"],["^ ","^14",2,"^13",false,"^1;","^3R"]],"^T",511,"^V",511,"^15",2,"^1?",true,"^X",["^Y",[["^1J"],["^3O","^3P"]]],"^11","Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro)\n                            (n/token-node 42))\n       n/string)\n   ;; => \"#my-macro 42\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \"#my-macro    42\"\n   ```"],"~$comment?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",237,"^U",7,"^V",237,"^W",15,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` is a comment."],"^7","~$rewrite-clj.node/comment?","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",237,"^1B","^1E","^V",237,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Returns true if `node` is a comment."],"~$spaces",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",820,"^U",7,"^V",820,"^W",13,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Create node representing `n` spaces."],"^7","~$rewrite-clj.node/spaces","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["~$n"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",820,"^1B","^1H","^V",820,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Create node representing `n` spaces."],"~$raw-meta-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",372,"^U",7,"^V",372,"^W",20,"^X",["^Y",["^Z",["^Y",[["^1J"],["^2L","^2M"]]]]],"^11","Create a node representing a form with metadata that renders to the reader syntax.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \"#^:foo [2]\"\n\n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \"#^{:foo 42} [2]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \"#^:foo [2]\"\n   ```\n   See also: [[meta-node]]","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^2L","^2M"]],"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/raw-meta-node","^S","out/rewrite_clj/node.cljc","^W",20,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^1J"],["^2L","^2M"]],"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^17",["^Y",[null,null]]],"^16",[["^1J"],["^2L","^2M"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^2O"],["^ ","^14",2,"^13",false,"^1;","^2O"]],"^T",372,"^V",372,"^15",2,"^1?",true,"^X",["^Y",[["^1J"],["^2L","^2M"]]],"^11","Create a node representing a form with metadata that renders to the reader syntax.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \"#^:foo [2]\"\n\n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \"#^{:foo 42} [2]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \"#^:foo [2]\"\n   ```\n   See also: [[meta-node]]"],"~$comment-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",213,"^U",7,"^V",213,"^W",19,"^X",["^Y",["^Z",["^Y",[["~$s"],["^2V","~$s"]]]]],"^11","Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \"; my comment\\n\")\n       n/string)\n   ;; => \";; my comment\\n\"\n\n   (-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n       n/string)\n   ;; => \"#!/usr/bin/env bb\\n\"\n   ```","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["~$s"],["^2V","~$s"]],"^X",["^Y",[["~$s"],["^2V","~$s"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/comment-node","^S","out/rewrite_clj/node.cljc","^W",19,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["~$s"],["^2V","~$s"]],"^X",["^Y",[["~$s"],["^2V","~$s"]]],"^17",["^Y",[null,null]]],"^16",[["~$s"],["^2V","~$s"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^1<"],["^ ","^14",2,"^13",false,"^1;","~$rewrite-clj.node.comment/CommentNode"]],"^T",213,"^V",213,"^15",2,"^1?",true,"^X",["^Y",[["~$s"],["^2V","~$s"]]],"^11","Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \"; my comment\\n\")\n       n/string)\n   ;; => \";; my comment\\n\"\n\n   (-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n       n/string)\n   ;; => \"#!/usr/bin/env bb\\n\"\n   ```"],"~$set-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",612,"^U",7,"^V",612,"^W",15,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \"#{1 2 3}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \"#{1 1}\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values)."],"^7","~$rewrite-clj.node/set-node","^S","out/rewrite_clj/node.cljc","^W",15,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",612,"^1B","^1V","^V",612,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \"#{1 2 3}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \"#{1 1}\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values)."],"~$keyword-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",303,"^U",7,"^V",303,"^W",19,"^X",["^Y",["^Z",["^Y",[["~$k","^2U"],["~$k"]]]]],"^11","Create a node representing a keyword `k`.\n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \":kw\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \":my-prefix/kw\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \"::kw\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \"::ns-alias/kw\"\n   ```","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["~$k","^2U"],["~$k"]],"^X",["^Y",[["~$k","^2U"],["~$k"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/keyword-node","^S","out/rewrite_clj/node.cljc","^W",19,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["~$k","^2U"],["~$k"]],"^X",["^Y",[["~$k","^2U"],["~$k"]]],"^17",["^Y",[null,null]]],"^16",[["~$k","^2U"],["~$k"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",2,"^13",false,"^1;","~$rewrite-clj.node.keyword/KeywordNode"],["^ ","^14",1,"^13",false,"^1;","^44"]],"^T",303,"^V",303,"^15",2,"^1?",true,"^X",["^Y",[["~$k","^2U"],["~$k"]]],"^11","Create a node representing a keyword `k`.\n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \":kw\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \":my-prefix/kw\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \"::kw\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \"::ns-alias/kw\"\n   ```"],"~$symbol-node?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",776,"^U",7,"^V",776,"^W",19,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Returns true if `n` is a node representing a symbol."],"^7","~$rewrite-clj.node/symbol-node?","^S","out/rewrite_clj/node.cljc","^W",19,"^16",["^Y",[["~$n"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",776,"^1B","^1E","^V",776,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Returns true if `n` is a node representing a symbol."],"~$length",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",137,"^U",7,"^V",137,"^W",13,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return number of characters for the string version of `node`."],"^7","~$rewrite-clj.node/length","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",137,"^1B","^1<","^V",137,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Return number of characters for the string version of `node`."],"~$quote-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",676,"^U",7,"^V",676,"^W",17,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"^7","~$rewrite-clj.node/quote-node","^S","out/rewrite_clj/node.cljc","^W",17,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",676,"^1B","^3@","^V",676,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"~$unquote-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",718,"^U",7,"^V",718,"^W",19,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"^7","~$rewrite-clj.node/unquote-node","^S","out/rewrite_clj/node.cljc","^W",19,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",718,"^1B","^3@","^V",718,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"~$node?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",142,"^U",7,"^V",142,"^W",12,"^X",["^Y",["^Z",["^Y",[["~$x"]]]]],"^11","Returns true if `x` is a rewrite-clj created node."],"^7","~$rewrite-clj.node/node?","^S","out/rewrite_clj/node.cljc","^W",12,"^16",["^Y",[["~$x"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",142,"^1B","^1E","^V",142,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$x"]]]]],"^11","Returns true if `x` is a rewrite-clj created node."],"~$uneval-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",781,"^U",7,"^V",781,"^W",18,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing an unevaled form with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \"#_ 42\"\n   ```"],"^7","~$rewrite-clj.node/uneval-node","^S","out/rewrite_clj/node.cljc","^W",18,"^16",["^Y",[["^1J"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",781,"^1B","~$rewrite-clj.node.uneval/UnevalNode","^V",781,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^1J"]]]]],"^11","Create node representing an unevaled form with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \"#_ 42\"\n   ```"],"~$keyword-node?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",335,"^U",7,"^V",335,"^W",20,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Returns true if `n` is a node representing a keyword."],"^7","~$rewrite-clj.node/keyword-node?","^S","out/rewrite_clj/node.cljc","^W",20,"^16",["^Y",[["~$n"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",335,"^1B","^1E","^V",335,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["~$n"]]]]],"^11","Returns true if `n` is a node representing a keyword."],"~$line-separated",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",800,"^U",7,"^V",800,"^W",21,"^X",["^Y",["^Z",["^Y",[["^26"]]]]],"^11","Interleave `nodes` with newline nodes."],"^7","~$rewrite-clj.node/line-separated","^S","out/rewrite_clj/node.cljc","^W",21,"^16",["^Y",[["^26"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",800,"^1B","~$seq","^V",800,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^26"]]]]],"^11","Interleave `nodes` with newline nodes."],"~$token-node",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",760,"^U",7,"^V",760,"^W",17,"^X",["^Y",["^Z",["^Y",[["^21"],["^21","~$string-value"]]]]],"^11","Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \"sym\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \"42\"\n   ```","^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^21"],["^21","^4H"]],"^X",["^Y",[["^21"],["^21","^4H"]]],"^17",["^Y",[null,null]]]],"^7","~$rewrite-clj.node/token-node","^S","out/rewrite_clj/node.cljc","^W",17,"^12",["^ ","^13",false,"^14",2,"^15",2,"^16",[["^21"],["^21","^4H"]],"^X",["^Y",[["^21"],["^21","^4H"]]],"^17",["^Y",[null,null]]],"^16",[["^21"],["^21","^4H"]],"^19",null,"^14",2,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^1:",[["^ ","^14",1,"^13",false,"^1;","^1<"],["^ ","^14",2,"^13",false,"^1;","~$clj"]],"^T",760,"^V",760,"^15",2,"^1?",true,"^X",["^Y",[["^21"],["^21","^4H"]]],"^11","Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \"sym\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \"42\"\n   ```"],"~$whitespace-or-comment?",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",242,"^U",7,"^V",242,"^W",29,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Check whether the given node represents whitespace or comment."],"^7","~$rewrite-clj.node/whitespace-or-comment?","^S","out/rewrite_clj/node.cljc","^W",29,"^16",["^Y",[["^["]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",242,"^1B","^1E","^V",242,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^11","Check whether the given node represents whitespace or comment."],"^6",["^ ","^Q",null,"^R",["^ ","^S","/Users/shivamsinghal/projects/open-source/clj-formatter/out/rewrite_clj/node.cljc","^T",108,"^U",7,"^V",108,"^W",13,"^X",["^Y",["^Z",["^Y",[["~$form"]]]]],"^11","Coerce `form` to node."],"^7","~$rewrite-clj.node/coerce","^S","out/rewrite_clj/node.cljc","^W",13,"^16",["^Y",[["^4M"]]],"^19",null,"^17",["^Y",[null,null]],"^U",1,"^13",false,"^T",108,"^1B","^1<","^V",108,"^15",1,"^1?",true,"^X",["^Y",["^Z",["^Y",[["^4M"]]]]],"^11","Coerce `form` to node."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^I","^I"],"^11","Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[list-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]","~:as-aliases",["^ "]]